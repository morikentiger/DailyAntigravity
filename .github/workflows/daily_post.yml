name: DailyAG Auto Post

on:
  push:
    paths:
      - 'Day*/**/*.md'

jobs:
  post:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'skip-post')"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          pip install atproto
          sudo apt-get update && sudo apt-get install -y ffmpeg webp

      - name: Parse and Post
        shell: python
        env:
          BSKY_IDENTIFIER: ${{ secrets.BSKY_IDENTIFIER }}
          BSKY_PASSWORD: ${{ secrets.BSKY_PASSWORD }}
        run: |
          import os
          import re
          import subprocess
          import glob
          from atproto import Client

          # Bluesky supported video formats
          BSKY_VIDEO_FORMATS = {'.mp4', '.webm', '.mov', '.mpeg'}
          # Formats that need conversion
          CONVERT_FORMATS = {'.webp', '.gif'}
          IMAGE_EXTENSIONS = {'.png', '.jpg', '.jpeg', '.bmp'}

          def is_bsky_video(filename):
              return os.path.splitext(filename)[1].lower() in BSKY_VIDEO_FORMATS

          def needs_conversion(filename):
              return os.path.splitext(filename)[1].lower() in CONVERT_FORMATS

          def is_image(filename):
              return os.path.splitext(filename)[1].lower() in IMAGE_EXTENSIONS

          def convert_animated_webp_to_mp4(input_path):
              """Convert animated WebP to MP4 via GIF intermediate"""
              base_path = os.path.splitext(input_path)[0]
              gif_path = base_path + '_temp.gif'
              output_path = base_path + '_converted.mp4'

              print(f"Converting animated WebP {input_path} to MP4...")

              try:
                  # Step 1: Convert WebP to GIF using webpmux and convert
                  # First try direct gif2webp reverse (anim_dump)
                  result = subprocess.run([
                      'ffmpeg', '-y', '-f', 'gif', '-i', input_path,
                      '-movflags', 'faststart',
                      '-pix_fmt', 'yuv420p',
                      '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2',
                      output_path
                  ], capture_output=True, text=True, timeout=120)

                  if result.returncode == 0 and os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                      print(f"Direct conversion successful: {output_path}")
                      return output_path

                  # If that fails, try using img2webp in reverse via frames
                  print("Direct conversion failed, trying alternative method...")

                  # Try treating as image sequence
                  result = subprocess.run([
                      'ffmpeg', '-y',
                      '-framerate', '10',
                      '-pattern_type', 'glob', '-i', input_path,
                      '-c:v', 'libx264',
                      '-movflags', 'faststart',
                      '-pix_fmt', 'yuv420p',
                      output_path
                  ], capture_output=True, text=True, timeout=120)

                  if result.returncode == 0 and os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                      print(f"Alternative conversion successful: {output_path}")
                      return output_path

                  print(f"All conversion methods failed: {result.stderr}")
                  return None

              except Exception as e:
                  print(f"Conversion error: {e}")
                  return None

          def convert_gif_to_mp4(input_path):
              """Convert GIF to MP4 using ffmpeg"""
              output_path = os.path.splitext(input_path)[0] + '_converted.mp4'
              print(f"Converting GIF {input_path} to {output_path}...")
              try:
                  result = subprocess.run([
                      'ffmpeg', '-y', '-i', input_path,
                      '-movflags', 'faststart',
                      '-pix_fmt', 'yuv420p',
                      '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2',
                      output_path
                  ], capture_output=True, text=True, timeout=120)
                  if result.returncode == 0 and os.path.exists(output_path) and os.path.getsize(output_path) > 0:
                      print(f"GIF conversion successful: {output_path}")
                      return output_path
                  else:
                      print(f"GIF conversion failed: {result.stderr}")
                      return None
              except Exception as e:
                  print(f"GIF conversion error: {e}")
                  return None

          def find_fallback_images(log_dir):
              """Find any PNG/JPG images in the media folder as fallback"""
              media_dir = os.path.join(log_dir, 'media')
              fallback_images = []
              if os.path.exists(media_dir):
                  for ext in IMAGE_EXTENSIONS:
                      fallback_images.extend(glob.glob(os.path.join(media_dir, f'*{ext}')))
              print(f"Found fallback images: {fallback_images}")
              return fallback_images

          def post_to_bsky():
              # Find all .md files (Log.md) in the structure
              files = []
              for root, _, f_names in os.walk('.'):
                  if 'Day' in root and '.gemini' not in root:
                      for f in f_names:
                          if f.endswith('.md'):
                              files.append(os.path.join(root, f))

              if not files:
                  print("No .md files found.")
                  return

              print(f"Found {len(files)} files: {files}")

              # Find files marked with 'OK_TO_POST: yes'
              target_files = []
              for path in files:
                  try:
                      with open(path, 'r') as f:
                          if 'OK_TO_POST: yes' in f.read():
                              target_files.append(path)
                  except:
                      continue

              if not target_files:
                  print("No files marked with 'OK_TO_POST: yes' found.")
                  return

              # Use mtime among target files
              latest_file = max(target_files, key=os.path.getmtime)
              print(f"Targeting: {latest_file}")

              with open(latest_file, 'r') as f:
                  content = f.read()

              # Extract POST section
              post_match = re.search(r'##\s*POST\s*\n(.*?)\n##', content, re.DOTALL | re.IGNORECASE)
              if not post_match:
                  post_match = re.search(r'##\s*POST\s*\n(.*?)$', content, re.DOTALL | re.IGNORECASE)

              if not post_match:
                  print("Could not parse POST section.")
                  return

              post_text = post_match.group(1).split('##')[0].strip()
              print(f"Post text extracted: {post_text[:50]}...")

              # Extract media from ARTIFACTS
              log_dir = os.path.dirname(latest_file)
              videos = []
              images = []

              # Look for video first
              video_match = re.search(r'-\s*(?:動画|Video)：\s*(.*?)(?:\n|$)', content, re.IGNORECASE)
              if video_match:
                  media_paths = [p.strip() for p in video_match.group(1).split(',') if p.strip()]
                  print(f"Found video paths in log: {media_paths}")
                  for media_path in media_paths:
                      full_path = os.path.join(log_dir, media_path)
                      if os.path.exists(full_path):
                          ext = os.path.splitext(full_path)[1].lower()
                          if ext == '.webp':
                              converted = convert_animated_webp_to_mp4(full_path)
                              if converted:
                                  videos.append(converted)
                          elif ext == '.gif':
                              converted = convert_gif_to_mp4(full_path)
                              if converted:
                                  videos.append(converted)
                          elif is_bsky_video(full_path):
                              videos.append(full_path)
                          print(f"Processed video file: {full_path}")

              # Look for screenshots/images
              img_match = re.search(r'-\s*(?:スクリーンショット|Screenshot)：\s*(.*?)(?:\n|$)', content, re.IGNORECASE)
              if img_match:
                  media_paths = [p.strip() for p in img_match.group(1).split(',') if p.strip()]
                  print(f"Found image paths in log: {media_paths}")
                  for media_path in media_paths:
                      full_path = os.path.join(log_dir, media_path)
                      if os.path.exists(full_path) and is_image(full_path):
                          images.append(full_path)
                          print(f"Found image file: {full_path}")

              # If no videos converted successfully, look for fallback images
              if not videos and not images:
                  print("No videos or explicit images found, looking for fallback images...")
                  images = find_fallback_images(log_dir)

              print("Logging in to Bluesky...")
              client = Client()
              client.login(os.environ['BSKY_IDENTIFIER'], os.environ['BSKY_PASSWORD'])

              # Priority: Video > Images > Text only
              if videos:
                  video_path = videos[0]
                  print(f"Uploading video: {video_path}")
                  with open(video_path, 'rb') as f:
                      video_data = f.read()
                  root_post = client.send_video(
                      text=post_text,
                      video=video_data,
                      video_alt='DailyAG Video Artifact'
                  )
                  print(f"Successfully posted VIDEO to Bluesky! URI: {root_post.uri}")
              elif images:
                  from atproto import models
                  blobs = []
                  for img in images[:4]:
                      with open(img, 'rb') as f:
                          img_data = f.read()
                          resp = client.upload_blob(img_data)
                          blobs.append(models.AppBskyEmbedImages.Image(alt='DailyAG Artifact', image=resp.blob))
                  embed = models.AppBskyEmbedImages.Main(images=blobs)
                  print(f"Uploaded {len(blobs)} images.")
                  root_post = client.send_post(text=post_text, embed=embed)
                  print(f"Successfully posted IMAGES to Bluesky! URI: {root_post.uri}")
              else:
                  root_post = client.send_post(text=post_text)
                  print(f"Successfully posted TEXT ONLY to Bluesky! URI: {root_post.uri}")

          if __name__ == "__main__":
              post_to_bsky()
